module compiler.zhabakNewSchool;

import std.stdio;
import std.string;
import std.file;
import std.array;
import std.format;
import lexer.lexer;

class Compiler
{
private:
    Lexer lexer;
    Token[] tokens;
    size_t currentToken;
    File jsFile;
    int indentLevel = 0;

public:
    this()
    {
        lexer = new Lexer("");
        currentToken = 0;
    }

    ~this()
    {
        if (jsFile.isOpen)
            jsFile.close();
    }

    void compileFile(string filename)
    {
        string code = readText(filename);
        string jsFilename = filename.replace(".zh", ".js");
        
        jsFile = File(jsFilename, "w");
        compile(code);
    }

    void compile(string code)
    {
        lexer = new Lexer(code);
        tokens = lexer.lex();
        currentToken = 0;

        writeLine("// Generated by zh compiler");
        writeLine("const util = require('util');");
        writeLine("(function() {");
        indentLevel++;

        while (currentToken < tokens.length && peek().type != TokenType.EOF)
        {
            parseStatement();
        }

        indentLevel--;
        writeLine("})();");
    }

private:
    Token peek() 
    { 
        return currentToken < tokens.length ? tokens[currentToken] : new Token(TokenType.EOF, "", 0, 0); 
    }
    
    Token consume(TokenType expected, string err = "Unexpected token")
    {
        if (peek().type == expected) return tokens[currentToken++];
        throw new Exception(err);
    }

    void writeLine(string line)
    {
        writeIndent();
        jsFile.writeln(line);
    }

    void writeIndent()
    {
        foreach (_; 0 .. indentLevel)
        {
            jsFile.write("    "); // 4 пробела на уровень
        }
    }

    void parseStatement()
    {
        if (peek().type == TokenType.EOF) return;

        switch (peek().type)
        {
            case TokenType.WRITE:
            case TokenType.WRITELN:
            case TokenType.WRITEF:
                parsePrint();
                break;
                
            case TokenType.IF:
                parseIf();
                break;

            case TokenType.ELSE:
                parseElse();
                break;

            case TokenType.LBRACE:
                parseBlock();
                break;

            case TokenType.RBRACE:
                consume(TokenType.RBRACE);
                break;

            case TokenType.VARIABLE:
            case TokenType.VAR:
                parseVar();
                break;
                
            default:
                throw new Exception(format("Unknown statement: %s", peek().type));
        }
    }

    void parseBlock()
    {
        consume(TokenType.LBRACE);
        writeLine("{");
        indentLevel++;
        
        while (peek().type != TokenType.RBRACE && peek().type != TokenType.EOF)
        {
            parseStatement();
        }
        
        indentLevel--;
        writeLine("}");
        consume(TokenType.RBRACE);
    }

    void parsePrint()
    {
        bool newline = false;
        bool isWritef = false;

        switch(peek().type)
        {
            case TokenType.WRITELN:
                newline = true;
                consume(TokenType.WRITELN);
                break;

            case TokenType.WRITEF:
                isWritef = true;
                consume(TokenType.WRITEF);
                break;

            default:
                consume(TokenType.WRITE);
                break;
        }

        consume(TokenType.LPAREN);

        if(isWritef)
        {
            parseWritef(newline);
        }
        else
        {
            string[] args;
            while (peek().type != TokenType.RPAREN)
            {
                args ~= parseExpr();
                if (peek().type == TokenType.COMMA) consume(TokenType.COMMA);
            }
            consume(TokenType.RPAREN);
            consume(TokenType.SEMICOLON);
            
            if (newline)
            {
                writeLine(format("console.log(%s);", args.join(", ")));
            }
            else
            {
                writeLine(format("process.stdout.write(%s);", args.join(" + ")));
            }
        }
    }

    void parseWritef(bool newline)
    {
        string formatStr = parseExpr();
        string[] args;
        
        if (peek().type == TokenType.TILDE)
        {
            consume(TokenType.TILDE);
            while (peek().type != TokenType.RPAREN)
            {
                args ~= parseExpr();
                if (peek().type == TokenType.TILDE) consume(TokenType.TILDE);
            }
        }
        
        consume(TokenType.RPAREN);
        consume(TokenType.SEMICOLON);
        
        if (newline)
        {
            if (args.length == 0)
            {
                writeLine(format("console.log(%s);", formatStr));
            }
            else
            {
                writeLine(format("console.log(util.format(%s, %s));", 
                               formatStr, args.join(", ")));
            }
        }
        else
        {
            if (args.length == 0)
            {
                writeLine(format("process.stdout.write(%s);", formatStr));
            }
            else
            {
                writeLine(format("process.stdout.write(util.format(%s, %s));", 
                               formatStr, args.join(", ")));
            }
        }
    }

    void parseVar()
    {
        consume(TokenType.VAR);
        string name = consume(TokenType.VARIABLE).value;
        
        if(peek().type != TokenType.ASSIGNMENT)
        {
            throw new Exception(format("Expected '=' after variable name, got '%s'", peek().value));
        }

        consume(TokenType.ASSIGNMENT);
        string value = parseExpr();
        consume(TokenType.SEMICOLON);
        writeLine(format("let %s = %s;", name, value));
    }

    void parseIf()
    {
        consume(TokenType.IF);
        consume(TokenType.LPAREN);
        string condition = parseComparison();
        consume(TokenType.RPAREN);
        
        writeIndent();
        jsFile.writefln("if(" ~ condition ~ ") ");
        
        if(peek().type == TokenType.LBRACE)
        {
            parseBlock();
        }

        else
        {
            indentLevel++;
            writeln("");
            parseStatement();
            indentLevel--;
        }

        if(peek().type == TokenType.ELSE)
        {
            parseElse();
        }
    }

    void parseElse()
    {
        consume(TokenType.ELSE);

        if(peek().type == TokenType.IF)
        {
            writeIndent();
            jsFile.writefln("else ");
            parseIf();
            return;
        }

        writeIndent();
        jsFile.write("else ");

        if(peek().type == TokenType.LBRACE)
        {
            parseBlock();
        }

        else 
        {
            indentLevel++;
            writeln("");
            parseStatement();
            indentLevel--;
        }
    }

    string parseComparison()
    {
        string left = parseExpr();

        while(peek().type == TokenType.LESS || peek().type == TokenType.GREATER || peek().type == TokenType.LESS_EQUAL || peek().type == TokenType.GREATER_EQUAL || peek().type == TokenType.EQUALS || peek().type == TokenType.NOT_EQUAL)
        {
            string op = consume(peek().type).value;
            string right = parseExpr();
            left = format("(%s %s %s)", left, op, right);
        }

        return left;
    }

    string parseExpr()
    {
        string left = parseTerm();
        
        while (peek().type == TokenType.PLUS || peek().type == TokenType.MINUS)
        {
            string op = consume(peek().type).value;
            left = format("(%s %s %s)", left, op, parseTerm());
        }
        
        return left;
    }

    string parseTerm()
    {
        string left = parseFactor();
        
        while (peek().type == TokenType.MULTIPLY || peek().type == TokenType.DIVIDE)
        {
            string op = consume(peek().type).value;
            string right = parseFactor();
            left = format("(%s %s %s)", left, op, right);
        }
        
        return left;
    }

    string parseFactor()
    {
        if (peek().type == TokenType.PLUS || peek().type == TokenType.MINUS)
        {
            string op = consume(peek().type).value;
            return format("%s%s", op, parseFactor());
        }

        auto token = consume(peek().type);
        
        switch (token.type)
        {
            case TokenType.LITERAL_NUMBER:
            case TokenType.LITERAL_STRING:
                return token.value;
                
            case TokenType.VARIABLE:
                return token.value;
                
            case TokenType.LPAREN:
                string expr = parseExpr();
                consume(TokenType.RPAREN);
                return expr;
                
            default:
                throw new Exception(format("Invalid factor: %s", token.type));
        }
    }
}

void main(string[] args)
{
    if (args.length < 2)
    {
        writeln("Usage: zhabak file.zh");
        return;
    }

    auto compiler = new Compiler();
    scope(exit) compiler = null;
    compiler.compileFile(args[1]);
}