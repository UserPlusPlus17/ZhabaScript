module compiler.zhabakNewSchool;

import std.stdio;
import std.string;
import std.file;
import std.array;
import lexer.lexer;


class Compiler
{
private:
    Lexer lexer;
    Token[] tokens;
    size_t currentToken;
    string[] jsCode;

public:
    this()
    {
        lexer = new Lexer("");
        currentToken = 0;
        jsCode = [];
    }

    void compileFile(string filename)
    {
        string code = readText(filename);
        compile(code);
        string jsFilename = filename.replace(".zh", ".js");
        generateJavaScript(jsFilename);
    }

    void compile(string code)
    {
        lexer = new Lexer(code);
        tokens = lexer.lex();
        currentToken = 0;

        jsCode ~= "// Generated by zh compiler";
        jsCode ~= "(function() {";

        while (currentToken < tokens.length && peek().type != TokenType.EOF)
        {
            parseStatement();
        }

        jsCode ~= "})();";
    }

private:
    Token peek() 
    { 
        return currentToken < tokens.length ? tokens[currentToken] : new Token(TokenType.EOF, "", 0, 0); 
    }
    
    Token consume(TokenType expected, string err = "Unexpected token")
    {
        if (peek().type == expected) return tokens[currentToken++];
        throw new Exception(err);
    }

    void parseStatement()
    {
        switch (peek().type)
        {
            case TokenType.WRITE:
            case TokenType.WRITELN:
            case TokenType.WRITEF:
                parsePrint();
                break;
                
            case TokenType.VARIABLE:
                parseVar();
                break;
                
            default:
                throw new Exception(format("Unknown statement: %s", peek().type));
        }
    }

    void parsePrint()
    {
        // bool newline = peek().type == TokenType.WRITELN;
        // consume(newline ? TokenType.WRITELN : TokenType.WRITE);
        // string expr = parseExpr();
        // consume(TokenType.SEMICOLON);
        // jsCode ~= format("  console.log(%s);", expr);

        bool newline = false;
        bool isWritef = false;

        switch(peek().type)
        {
            case TokenType.WRITELN:
                newline = true;
                consume(TokenType.WRITELN);
                break;

            case TokenType.WRITEF:
                isWritef = true;
                consume(TokenType.WRITEF);
                break;

            default:
                consume(TokenType.WRITE);
                break;
        }

        consume(TokenType.LPAREN);

        if(isWritef)
        {
            parseWritef(newline);
        }

        else
        {
            string[] args;

            while (peek().type != TokenType.RPAREN)
            {
                args ~= parseExpr();
                if (peek().type == TokenType.COMMA) consume(TokenType.COMMA);
            }
            consume(TokenType.RPAREN);
            consume(TokenType.SEMICOLON);
            
            if (newline)
            {
                jsCode ~= format("  console.log(%s);", args.join(", "));
            }

            else
            {
                jsCode ~= format("  process.stdout.write(%s);", args.join(" + "));
            }
        }
    }

    void parseWritef(bool newline)
    {
        string formatStr = parseExpr();
        string[] args;
        
        if (peek().type == TokenType.COMMA)
        {
            consume(TokenType.COMMA);
            while (peek().type != TokenType.RPAREN)
            {
                args ~= parseExpr();
                if (peek().type == TokenType.COMMA) consume(TokenType.COMMA);
            }
        }
        
        consume(TokenType.RPAREN);
        consume(TokenType.SEMICOLON);
        
        string jsArgs = formatStr;
        if (args.length > 0)
        {
            jsArgs ~= ", " ~ args.join(", ");
        }
        
        if (newline)
        {
            jsCode ~= format("  console.log(%s);", jsArgs);
        }

        else
        {
            jsCode ~= format("  process.stdout.write(%s);", jsArgs);
        }
    }

    void parseVar()
    {
        string name = consume(TokenType.VARIABLE).value;
        consume(TokenType.ASSIGNMENT);
        string value = parseExpr();
        consume(TokenType.SEMICOLON);
        jsCode ~= format("  let %s = %s;", name, value);
    }

    string parseExpr()
    {
        string left = parseTerm();
        
        while (peek().type == TokenType.PLUS || peek().type == TokenType.MINUS)
        {
            string op = consume(peek().type).value;
            left = format("(%s %s %s)", left, op, parseTerm());
        }
        
        return left;
    }

    string parseTerm()
    {
        string left = parseFactor();
        
        while (peek().type == TokenType.MULTIPLY || peek().type == TokenType.DIVIDE)
        {
            string op = consume(peek().type).value;
            string right = parseFactor();
            left = format("(%s %s %s)", left, op, right);
        }
        
        return left;
    }

    string parseFactor()
    {
        if (peek().type == TokenType.PLUS || peek().type == TokenType.MINUS)
        {
            string op = consume(peek().type).value;
            return format("%s%s", op, parseFactor());
        }

        auto token = consume(peek().type);
        
        switch (token.type)
        {
            case TokenType.LITERAL_NUMBER:
            case TokenType.LITERAL_STRING:
                return token.value;
                
            case TokenType.VARIABLE:
                return token.value;
                
            case TokenType.LPAREN:
                string expr = parseExpr();
                consume(TokenType.RPAREN);
                return expr;
                
            default:
                throw new Exception(format("Invalid factor: %s", token.type));
        }
    }

    void generateJavaScript(string filename)
    {
        File file = File(filename, "w");
        file.writeln(join(jsCode, "\n"));
        file.close();
    }
}

void main(string[] args)
{
    if (args.length < 2)
    {
        writeln("Usage: zhabak file.zh");
        return;
    }

    auto compiler = new Compiler();
    compiler.compileFile(args[1]);
}